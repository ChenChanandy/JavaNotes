- [Java入门](#Java入门)
- [面向对象](#面向对象)

## Java入门

### Java各版本的含义

**JavaSE**(Java Standard Edition)：标准版，定位在个人计算机上的应用。这个版本是Java平台的核心，它提供了非常丰富的API来开发一般个人计算机上的应用程序，包括用户界面接口AWT及Swing，网络功能与国际化、图像处理能力以及输入输出支持等。

**JavaEE**(Java Enterprise Edition)：企业版，定位在服务器端的应用。JavaEE是javaSE的扩展，增加了用于服务器开发的类库。

**JavaME**(Java Micro Edition)：微型版，定位在消费性电子产品的应用上。**安卓开发不是JavaME**。

### JVM、JRE和JDK

**JVM** (Java Virtual Machine) 就是一个虚拟的用于执行bytecode字节码的”虚拟计算机”。

**JRE** (Java Runtime Environment) 包含：Java虚拟机、库函数、运行Java应用程序所必须的文件。

**JDK** (Java  Development Kit) 包含：包含JRE，以及增加编译器和调试器等用于程序开发的文件。

### JDK环境变量配置

```properties
变量名(N): JAVA_HOME
变量值(V): C:\Program Files\Java\jdk1.8.0_191(JDK安装目录)

修改系统环境变量Path，在最前面追加 %JAVA_HOME%\bin 并以;和原路径分隔。再增加：“.;”。这是表示当前目录的意思。
```

`cmd` 进入命令行窗口，输入`java-version` 查看JDK安装和配置是否成功。

**编译**：执行命令 `javac HelloWorld.java` ，生成class文件。

**解释并运行**：执行命令 `java HelloWorld` ，输出执行结果。

### 注释

**单行注释**：使用“//”开头，“//”后面的单行内容均为注释。

**多行注释**：以“/*”开头以“*/”结尾，在“/*”和“*/”之间的内容为注释，我们也可以使用多行注释作为行内注释。但是在使用时要注意，多行注释不能嵌套使用。

**文档注释**：以“/**”开头以“*/”结尾，注释中包含一些说明性的文字及一些JavaDoc标签(后期写项目时，可以生成项目的API)

```java
/**
 * Welcome类（我是文档注释）
 * @author 
 * @version 1.0
 */
public class Welcome {
    //我是单行注释
    public static void main(String[] args/*我是行内注释 */) {
        System.out.println("Hello World!");
    }
    /*
       我是多行注释！
       我是多行注释！
     */
}
```

### 标识符

**规则**

- 标识符必须以字母、下划线_、美元符号$开头。  
- 标识符其它部分可以是字母、下划线“_”、美元符“$”和数字的任意组合。
- Java 标识符大小写敏感，且长度无限制。
- 标识符不可以是Java的关键字。

**使用规范**

- 表示类名的标识符：每个单词的首字母大写，如Man, GoodMan
- 表示方法和变量的标识符：第一个单词小写，从第二个单词开始首字母大写，我们称之为“驼峰原则”，如eat(), eatFood()
- Java不采用通常语言使用的 ASCII 字符集，而是采用 **Unicode** 这样标准的国际字符集。因此，这里字母的含义不仅仅是英文，还包括汉字等等。但是不建议使用汉字来定义标识符！

### 基本数据类型

|  类型   | 占用存储空间 |                   表数范围                   |
| :-----: | :----------: | :------------------------------------------: |
|  byte   |    1字节     |         -2^7^ ~   2^7^-1（-128~127）         |
|  short  |    2字节     |      -2^15^ ~   2^15^-1（-32768~32767）      |
|   int   |    4字节     | 2^31^ ~ 2^31^-1 (-2147483648~2147483647)约21 |
|  long   |    8字节     |               -2^63^ ~ 2^63^-1               |
|  float  |    4字节     |              -3.403E38~3.403E38              |
| double  |    8字节     |             -1.798E308~1.798E308             |
|  char   |    2字节     |              允许有65536个字符               |
| boolean |    占一位    |                true 和 false                 |

**Java 语言整型常量的四种表示形式**

- 十进制整数，如：99, -500, 0
- 八进制整数，要求以 0 开头，如：015
- 十六进制数，要求 0x 或 0X 开头，如：0x15
- 二进制数，要求0b或0B开头，如：0b01110011

Java语言的整型常数默认为int型，声明long型常量可以后加‘ l ’或‘ L ’ 。

float类型的数值有一个后缀F或者f ，没有后缀F/f的浮点数值默认为double类型。

java.math包下面的两个有用的类：BigInteger 和 BigDecimal，这两个类可以处理任意长度的数值。BigInteger实现了任意精度的整数运算。BigDecimal实现了任意精度的浮点运算。

### 引用数据类型

类(class)，接口(interface)，数组

### 运算符

| 算术运算符 | +，-，*，/，%，++，--                                        |
| :--------- | :----------------------------------------------------------- |
| 逻辑运算符 | &，\|，&&，\|\|，!(非)，^(异或：相同为false，不同为true)     |
| 位运算符   | ~(取反)、&(按位与)、(按位或)、^(按位异或)、<<(左移，1位相当乘2)、>>(右移，1位相当除2) |
| 条件运算符 | x ? y : z                                                    |

### 使用Scanner获取键盘输入

```java
public class TestScanner {
	public static void main(String[] args) {
		Scanner   scanner = new Scanner(System.in);
        System.out.println("请输入名字：");
        String name = scanner.nextLine();
		System.out.println(name);        
	}
}
```

### 控制语句

#### if单选择结构

```java
if(布尔表达式){
    语句块
}
```

#### if-else双选择结构

```java
if(布尔表达式){
	语句块1
}else{
	语句块2
}
```

#### if-else if-else多选择结构

```java
if(布尔表达式1) {
	语句块1;
} else if(布尔表达式2) {
	语句块2;
}……
else if(布尔表达式n){
	语句块n;
} else {
	语句块n+1;
}
```

#### switch多选择结构

```java
switch (表达式) {
	case 值1: 
	语句序列1;
	[break];
	case 值2:
	 语句序列2;
	[break];
     … 
	[default:
	默认语句;]
}
```

#### while循环

```java
while (布尔表达式) {
	循环体;
}
```

#### do-while循环

```java
//do-while 总是保证循环体至少会被执行一次
do {
	循环体;
} while(布尔表达式) ;
```

#### for循环

```java
for (初始表达式; 布尔表达式; 迭代因子) {
	循环体;
}
```

#### 嵌套循环

```java
//九九乘法表
public class Test {
    public static void main(String args[]) {
        for (int i = 1; i < 10; i++) { // i是一个乘数
            for (int j = 1; j <= i; j++) { // j是另一个乘数
                System.out.print(j+ "*" + i + "=" + (i * j < 10 ? (" " + i * j) : i * j) + "  ");
            }
            System.out.println();
        }
    }
}
```



## 面向对象

### 对象和类

- 对象是具体的事物，类是对对象的抽象。

- 类可以看成一类对象的模板，对象可以看成该类的一个具体实例。

- 类是用于描述同一类型的对象的一个抽象概念，类中定义了这一类对象所应具有的共同的属性、方法。

对于一个类来说，一般有三种常见的成员：属性field、方法method、构造器constructor。

### 内存分析

**栈（stack）**

- 栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧(存储局部变量、操作数、方法出口等)

- JVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数、局部变量等)

- 栈属于线程私有，不能实现线程间的共享!

- 栈的存储特性是“先进后出，后进先出”

- 栈是由系统自动分配，速度快!栈是一个连续的内存空间。

**堆（heap）**

- 堆用于存储创建好的对象和数组(数组也是对象)。

- JVM只有一个堆，被所有线程共享。

- 堆是一个不连续的内存空间，分配灵活，速度慢。

**方法区（method area）**

- JVM只有一个方法区，被所有线程共享。

- 方法区实际也是堆，只是用于存储类、常量相关的信息。

- 用来存放程序中永远是不变或唯一的内容。(类信息【Class对象】、静态变量、字符串常量等)。

### 垃圾回收机制

#### 垃圾回收的原理和算法

**内存管理**

Java的内存管理很大程度指的就是对象的管理，其中包括对象空间的分配和释放。

对象空间的分配：使用new关键字创建对象即可

对象空间的释放：将对象赋值null即可。垃圾回收器将负责回收所有”不可达”对象的内存空间。

**垃圾回收过程**

任何一种垃圾回收算法一般要做两件基本事情：1.发现无用的对象，2.回收无用对象占用的内存空间。

垃圾回收机制保证可以将“无用的对象”进行回收。无用的对象指的就是没有任何变量引用该对象。Java的垃圾回收器通过相关算法发现无用对象，并进行清除和整理。

**垃圾回收相关算法**

- 引用计数法

  堆中每个对象都有一个引用计数。被引用一次，计数加1。被引用变量值变为null，则计数减1，直到计数为0，则表示变成无用对象。优点是算法简单，缺点是“循环引用的无用对象”无法别识别。

- 复制

  把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。

- 标记-清除

  此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。

- 标记-整理

  此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。

#### 分代垃圾回收机制

分代垃圾回收机制，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。我们将对象分为三种状态：年轻代、年老代、持久代。JVM将堆内存划分为 Eden、Survivor 和 Tenured/Old 空间。

**年轻代**

所有新生成的对象首先都是放在Eden区。 年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象，对应的是Minor GC，每次 Minor GC 会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作，但是会浪费内存空间。当“年轻代”区域存放满对象后，就将对象存放到年老代区域。

**年老代**

在年轻代中经历了N(默认15)次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。年老代对象越来越多，我们就需要启动Major GC和Full GC(全量回收)，来一次大扫除，全面清理年轻代区域和年老代区域。

**持久代**

用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响。

**垃圾回收过程**

1. 新创建的对象，绝大多数都会存储在Eden中，

2. 当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（GC），将无用对象清理掉，然后剩余对象复制到某个Survivor中，如S1，同时清空Eden区。

3. 当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Survivor中，如S2，同时将Eden区中的不能清空的对象，也复制到S1中，保证Eden和S1，均被清空。

4. 重复多次(默认15次)Survivor中没有被清理的对象，则会复制到老年代Old(Tenured)区中，

5. 当Old区满了，则会触发一个一次完整地垃圾回收（FullGC），之前新生代的垃圾回收称为（minorGC）

#### JVM调优和Full GC

在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。有如下原因可能导致Full GC：

- 年老代(Tenured)被写满

- 持久代(Perm)被写满

- System.gc()被显式调用（程序建议GC启动，不是调用GC）

- 上一次GC之后Heap的各域分配策略动态变化

#### 开发中容易造成内存泄露的操作

**创建大量无用对象**

比如，我们在需要大量拼接字符串时，使用了String而不是StringBuilder。

```java
String str = "";
for (int i = 0; i < 10000; i++) {
    str += i;     //相当于产生了10000个String对象
}
```

**静态集合类的使用**

像HashMap、Vector、List等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放。

**各种连接对象(IO流对象、数据库连接对象、网络连接对象)未关闭**

IO流对象、数据库连接对象、网络连接对象等连接对象属于物理连接，和硬盘或者网络连接，不使用的时候一定要关闭。

**监听器的使用**

释放对象时，没有删除相应的监听器。

### 关键字

#### this

this的本质就是“创建好的对象的地址”! this不能用于static方法中。

#### static

在类中，用static声明的成员变量为静态成员变量，也称为类变量；在static方法中不可直接访问非static的成员。

#### super

super是直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方法或属性。

使用super调用普通方法，语句没有位置限制，可以在子类中随便调用。

若是构造方法的第一行代码没有显式的调用super(...)或者this(...)；那么Java默认都会调用super()，含义是调用父类的无参数构造方法。这里的super()可以省略。

#### final

- 修饰变量: 被他修饰的变量不可改变。一旦赋了初值，就不能被重新赋值。

  ```java
  final  int   MAX_SPEED = 120;
  ```

- 修饰方法：该方法不可被子类重写。但是可以被重载!

  ```java
  final  void  study(){}
  ```

- 修饰类: 修饰的类不能被继承。比如：Math、String等。

  ```java
  final   class  A {}
  ```

#### 参数传值机制

Java方法中所有参数都是“值传递”，也就是“传递的是值的副本”。

### 面向对象三大特性

#### 继承

- Java中类没有多继承，接口有多继承。

- 子类继承父类，可以得到父类的全部属性和方法 (除了父类的构造方法)，但不见得可以直接访问(比如，父类私有的属性和方法)。

- 如果定义一个类时，没有调用extends，则它的父类是：java.lang.Object。

#### 封装

封装就是把对象的属性和操作结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。

**优点**

- 提高代码的安全性
- 提高代码的复用性
- “高内聚”：封装细节，便于修改内部代码，提高可维护性
- “低耦合”：简化外部调用，便于调用者使用，便于扩展和协作

#### 多态

多态指的是同一个方法调用，由于对象不同可能会有不同的行为。

**要点**

- 多态是方法的多态，不是属性的多态（多态与属性无关）

- 多态存在的3个必要条件：继承，方法重写，父类引用指向子类对象
- 父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了。

### ==和equals方法

“==”代表比较双方是否相同。基本类型表示值相等，引用类型表示地址相等即是同一个对象。

Object 的 equals 方法默认就是比较两个对象的hashcode，是同一个对象的引用时返回 true 否则返回 false。但是，我们可以根据我们自己的要求重写equals方法。

JDK提供的一些类，如String、Date、包装类等，重写了Object的equals方法，调用这些类的equals方法，x.equals (y) ，当x和y所引用的对象是同一类对象且属性内容相等时（并不一定是相同对象），返回 true 否则返回 false。

### 抽象方法和抽象类

**抽象方法**：使用abstract修饰的方法，没有方法体，只有声明。定义的是一种“规范”，就是告诉子类必须要给抽象方法提供具体的实现。

**抽象类**：包含抽象方法的类就是抽象类。通过abstract方法定义规范，然后要求子类必须定义具体实现。通过抽象类，我们就可以做到严格限制子类的设计，使子类之间更加通用。

**抽象类的使用要点**

- 有抽象方法的类只能定义成抽象类
- 抽象类不能实例化，即不能用new来实例化抽象类
- 抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new实例，只能用来被子类调用
- 抽象类只能用来被继承
- 抽象方法必须被子类实现

### 接口(interface)

**定义**

- 访问修饰符：只能是public或默认。

- 接口名：和类名采用相同命名机制。

- extends：接口可以多继承。

- 常量：接口中的属性只能是常量，总是：public static final 修饰。不写也是。

- 方法：接口中的方法只能是：public abstract。 省略的话，也是public abstract。

**要点**

- 子类通过implements来实现接口中的规范。

- 接口不能创建实例，但是可用于声明引用变量类型。

- 一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是public的。

- JDK1.7之前，接口中只能包含静态常量、抽象方法，不能有普通属性、构造方法、普通方法。

- JDK1.8后，接口中包含普通的静态方法。